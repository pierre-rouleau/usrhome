#!/bin/sh
# SH FILE: showpath
#
# Purpose   : Print current PATH, one directory per line.
# Created   : Monday, March  4 2024.
# Author    : Pierre Rouleau <prouleau001@gmail.com>
# Time-stamp: <2024-04-01 17:37:54 EDT, updated by Pierre Rouleau>
#
# ----------------------------------------------------------------------------
# Module Description
# ------------------
#
# Print PATH's elements, one per line.
# Usage: showpath [-n] [MAN|LIB][PATH]
#
#  -n: when specified, a left justified number is printed on each line.
#
# On error,
# - Print error on stderr.
# - Exit code: 1:  invalid argument(s).
#              2:  specified environment variable is not defined.
#              3:  format of specified environment variable is incorrect.

# ----------------------------------------------------------------------------
# Dependencies
# ------------
#
# printf, sed, nl, tr

# ----------------------------------------------------------------------------
# Code
# ----
#
#
show_path()
{
    # Arg 1: string: "-n" or nothing.
    # vname: string: name of path envvar: PATH, LIBPATH or MANPATH

    eval path_value='$'$vname
    if [ -z "$path_value" ]; then
        >&2 echo "WARNING: $vname is not defined!"
        if [ "$vname" = "MANPATH" ]; then
            if which manpath > /dev/null; then
                if [ -n "$(manpath)" ]; then
                    >&2 echo " However the manpath command provides the list:"
                    if [ "$1" = "-n" ]; then
                        manpath | tr ':' '\n' | nl -b a -n ln
                    else
                        printf -- "- "
                        manpath | sed 's/:/:- /g' | tr ':' '\n'
                    fi
                    exit 0
                fi
            fi
        fi
        exit 2
    else
        if [ "$1" = "-n" ]; then
            echo "$path_value" | tr ':' '\n' | nl -b a -n ln
        else
            printf -- "- "
            echo "$path_value" | sed 's/:/:- /g' | tr ':' '\n'
        fi
        if echo "$path_value" | grep '::' > /dev/null; then
            >&2 echo "ERROR: $vname has empty entries!"
            exit 3
        elif echo "$path_value" | grep '^:' > /dev/null; then
            >&2 echo "ERROR: $vname starts with an empty entry!"
            exit 3
        elif echo "$path_value" | grep ':$' > /dev/null; then
            >&2 echo "ERROR: $vname ends with an empty entry!"
            exit 3
        fi
    fi
}


# Parse command line arguments
if [ -n "$2" ]; then
    # there's 2 arguments. Check if one of them is -n
    if [ "$1" = "-n" ]; then
        vname="$2"
    else
        vname="$2"
        shift
    fi
else
    if [ -z "$1" ]; then
        # No argument
        vname="PATH"
    else
        # 1 argument (or more than 2, but ignore the ones after 2)
        # and don't support -n after the variable name.
        if [ "$1" = "-n" ]; then
            vname="PATH"
        else
            vname="$1"
        fi
    fi

fi

# Parse further: check vname: only allow the valid ones
# since their name will be passed to eval; don't allow
# user input to be eval'ed; that would be a security risk.
# Print the path using show_path function for the valid
# variable names.
case $vname in
    'PATH')
        vname="PATH"
        show_path "$1"
        ;;

    'LIB'|'LIBPATH')
        vname="LIBPATH"
        show_path "$1"
        ;;

    'MAN'|'MANPATH')
        vname="MANPATH"
        show_path "$1"
        ;;

    *)
        >&2 echo "ERROR: showpath does not support $vname"
        >&2 echo " usage: showpath [[LIB|MAN]|PATH] [-n]"
        exit 1
esac

# ----------------------------------------------------------------------------
